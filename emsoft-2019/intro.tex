% !TEX root = main.tex
\section{Introduction}
\eva{General comment: it feels a bit long until the intro discusses the actual problem,
but it reads nicely and motivates the problem well, so it's probably fine}
\eva{General comment: should we add some more references to related work (and not only to MPC)?}
Model predictive control (MPC) is a technique to design control actions by solving finite-horizon open-loop
optimal control problems at each sampling instant.
The result of each optimization gives a sequence of optimal control actions, only the first of which is applied
to the process.
The same procedure is applied in the next time instant with a shifted time horizon and a new initial state, 
after receiving the updated values of the process state.
The optimization problem in MPC uses a dynamic model of the process, encodes all input and output (state) constraints, and 
optimizes a performance index. 
MPC has shown to be successful in a wide variety of industrial applications, due to its 
ability to systematically handle processes with many state and input variables as well as constraints on them. 

The main difference between MPC and conventional control is in the nature of the function that maps the measured outputs to control actions. 
MPC computes such a function \emph{online}, whereas a conventional controller pre-computes the function offline.
The online computations required in MPC limits its applicability to slow processes and fast computation platforms: 
the sampling time has to be large enough and the platform fast enough to allow enough time for solving the optimization problem
and obtaining the optimal action for the next time instance. 
Moreover, the optimization solver needs to be certified when using MPC in safety critical applications.

One way to tackle these problems is through \emph{explicit MPC} \cite{Bemporad:2002,Alessio2009}, which formulates the optimization
problem but computes offline a symbolic representation of the solution as a function of the state.
At run-time, the solution is evaluated on the current state as in conventional control.
For example, for linear time invariant models with linear constraints and quadratic costs, the optimization
problem for MPC can be modeled as a quadratic program, and explicit MPC techniques solve the optimization problem
using multi-parametric programming techniques.
The explicit solution is representable as a partition of the controller domain into a number of polyhedral regions,
and an affine map for each region.
The implementation of explicit MPC stores a lookup table of the affine maps and performs a number of affine computations
online to find the appropriate region for the current state and to evaluate the control.  
Explicit MPC thus expands the class of systems being controlled by MPC strategies, by taking out the need to compute fast online
or to certify a complex optimization routine.

However, there are still bottlenecks in implementing explicit MPC on resource-constrained embedded micro-controllers.
First, implementations of explicit MPCs can suffer from large memory usage, because the solution of the optimization
problem can involve many (often hundreds) of regions.
Since the memory consumption grows linearly with the number of regions, 
this can be a limited factor in using explicit MPC on resource-constrained micro-controllers.
Second, many low-end micro-controllers only support fixed-point arithmetic.
Errors in the controller implementation are inversely proportional to the number of bits used for representing each variable. 
An implementation of explicit MPC has to be \emph{robust} to 
implementation errors to be able to enforce hard constraints on the states at run time.

In this paper, we consider the problem of implementing explicit MPC on low-end microcontrollers with fixed-point arithmetic
in a \emph{memory-efficient} and \emph{robust} way.
We propose an automatic controller and mixed-precision implementation co-design technique that computes a minimal set \todo{What is meant by minimal?} of mixed
precision assignments for all variables while ensuring the resulting implementation error remains within the robustness margin.  


Our proposed method iteratively solves a robust version of the MPC which explicitly considers fixed-point implementation errors
in the model; see~\autoref{fig:overview}.
Initially, we estimate a bound $\Delta = \Delta_0$ on the implementation error and solve a
min-max quadratic program for explicit robust MPC \cite{delaPea:2005}, where the system
model has an explicit disturbance bounded by $\Delta$.
The solution is represented as a piecewise affine map.
We use an automated mixed-precision tuning tool to find an approximate implementation of the piecewise affine
map. 
We statically compute the error of the implementation, taking into account errors
in evaluating the affine maps as well as choosing the wrong affine map due to quantization.
If the error is at most $\Delta$, we are done: the implementation satisfies the robustness margin in the model.
If not, we increase the error bound $\Delta$ and run the loop again to find a new robust controller and find its best mixed-precision
implementation.

We have implemented our algorithm on top of Matlab's multi-parametric toolbox 
for robust explicit MPC~\cite{matlabMPT}
and the Daisy tool for multi-precision tuning and fixed-point error analysis \cite{Daisy}.
We have applied our technique on a number of standard benchmark examples.
Our implementation finds that our mixed-precision implementation can save up to 20\% memory (on average, XXX\%) in controller
implementations over a uniform-precision implementation (and a saving of XXX\% over a uniform 32-bit implementation), while
maintaining the correctness of the controller.
In absolute terms, the saving corresponds to YYY KB over a uniform precision implementation on our largest benchmark.
In each case, the analysis takes only a few minutes of computation.
We also demonstrate the scalability of our mixed-precision tuning and error bounds analysis:
we show that on explicit MPC controllers with thousands of regions, our tool finishes in a few minutes\todo{Hours?}.

