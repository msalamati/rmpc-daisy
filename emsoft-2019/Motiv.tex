% !TEX root = main.tex
\section{Motivation}

Model Predictive Control (MPC) refers to the class of control strategies that design control actions by solving a finite horizon optimal control problem at each sampling instant. While each optimization gives a sequence of optimal control actions, only the first action is applied to the process. The same procedure is applied in the next time instance after receiving the updated value of the process state. MPC has shown to be successful in industrial applications since it is able to handle large number of states and control actions and automatically considers constraints in the optimization.

The optimization of each time instance uses a dynamic model of the process to predict the future states and find the optimal sequence of actions that satisfies all the constraints. The objective function of the optimization is usually linear or quadratic. The resulting optimization problem can be cast as a linear program (LP) or quadratic program (LP), respectively, if the dynamic model is linear. For hybrid models with linear dynamics in each mode, the optimization problem can be cast as a mixed integer linear or quadratic program (MILP/MIQP). 

 The main difference between MPC and conventional control is in the nature of the function that maps the measured outputs to control actions. The former computes such a function online but the latter pre-computes it off-line. The required online computations in MPC limits its applicability to slow processes: the sampling time should be large enough to allow enough time for solving the optimization and obtaining the optimal action for the next time instance. Moreover, the optimization solver needs to be certified for using MPC in safety critical applications.
 % while the  therefore that in the latter the control function is pre-computed off-line.
These issues can be tackled using \emph{Explicit MPC} under proper assumptions on the model, constraints and the objective function. Explicit MPC solves the optimization problem off-line over a bounded domain of the state variables by using multiparametric programming techniques. The output of Explicit MPC is the optimal control actions as an ?explicit? function of the states which is piecewise affine. This expands the class of systems being controlled by MPC strategies since the implementation requires only storing a lookup table of linear gains and performing an affine computation using the appropriate gains at each time instance. A survey on Explicit MPC can be found in \cite{Alessio2009}. \Sadegh{fix the reference.}

In this section, we use a classical control example to explain the motivation behind this work. Consider the problem of designing stablizing control for an inverted pendulum which takes (polytopic) constraints over state variables and control inputs into account. The linearized descrete-time description for the open-loop system's dynamics is as follows:
	\begin{equation}
		\begin{bmatrix}
			 \theta_{k+1}\\
			\omega_{k+1}
		\end{bmatrix}=
		\begin{bmatrix}
			1 & T_s\\
			\frac{T_sg}{l}& (1-\frac{T_sb}{ml^2})		
		\end{bmatrix}
		\begin{bmatrix}
			\theta_k\\
			\omega_k
		\end{bmatrix}+
		\begin{bmatrix}
			0\\
			\frac{T_s}{ml^2}
		\end{bmatrix}u_k
		\label{eq:pendul_ss}
	\end{equation}
	where, $\theta$, $\omega$ and $u$ denote angular position, angular speed and input torque respectively; $g=9.81 m/s^2$ is the gravitational acceleration, $m$ the ball mass, $b$ the rotational fraction coefficient, $L$ the length of the bar and $T_s$ an appropriate sample time. Starting from an initial state, we would like the system's trajectory to converge into its equilibrium point while always $\theta\in[-\pi,\pi]$ and $\omega\in[-\pi/8,\pi/8]$. \\
	While there are many control schemes which can be used to stablize the system (e.g. LQR, state feedback), adding polytopic constraints, MPC schemes will be the best choice. 
	%In literature, many control schemes are proposed for stablizing the system around the equilibrium point. 
	%In order to design a controller which takes additional safety constraints are taken into account, model predictive control (MPC) schemes seem to be best candidate. 
	However, one major challenge for implementing model predictive controllers over embedded systems will be to solve MPC optimality problem within each time step. Since the system under consideration is LTI, one can use explicit MPC scheme proposed in [Bemporad:2002] which computes partitions over state space together with affine functions which are used to compute the optimal control input over their corresponding partition. For the inverted-pendulum example, the computed controller contains $12$, over each an affine function is provided for generating the control input.\\
	%To overcome this issue, in [Bemporad:2002], explicite MPC, a multi-parametric programming based approach is proposed for LTI systems. 
	In practice, EMPC will be implemented over relatively low-price embedded systems which have limited memory capacity and computational power. Computing the optimal control input can be efficiently done using for example binary tree search. However, the memory limit is more crucial as it increases proportional to the number of partitions.	Therefore, we would like to explore ways to reduce required memory for saving different coefficients corresponding to the controllers.
	On the other hand, most of the industrial embedded systems over which EMPC is implemented, only support fixed point arithmetic. Using fixed point arithmetic, will cause approximation error that is inversely proportional to the number of bits used for representing each variable. It is necessary to count for approximation error as it might lead into violation of the constraints. Therefore, one needs to formulate the problem as robust EMPC to count for disturbance input $|\delta|\leq \Delta$ which is summed up with the control input torque $u$ in each time step. %Setting the number of bits for storing different variables, one can compute the upper bound for approximation error, $\bar\omega$.
	%However, we would like to achieve the minimum number of bits to reduce memory requirements.
	Overlay, we would like to design a robust explicit model predictive controller, taking into account errors resulted by fixed-point arithmetic and more importantly, to come up with a set of varying precision assignment that covers all the coefficients that must be saved over the embedded system. To that end, one approach is to start with an initial $\Delta$; design a robust explicit MPC controller with respect to $\Delta$ and to use state of the art fixed-point error analyzers to decide for the number of bits for saving every parameter of the controller. Figure \ref{fig:overview} gives an overview of our proposed setup.\\
	Again, back to inverted pendulum example, choosing $\Delta=0$, we design an explicit MPC which contains $12$ regions and the same number of controllers. However, this value for $\Delta$ is not realizable as error resulted from fixed-point implementation cannot become zero. Therefore, we go ahead and choose $\Delta=0.1$. Solving robust EMPC problem for the new disturbance bound gives $14$ controllers. Next, we ask Daisy to provide us with fixed-point precisions for every variable that respects $\Delta$. Using the output of Daisy, we are able to reduce memory requirements for the embedded systems up-to $20\%$ comparing to the case that uniform fixed-point precision is used.
	
	
	
	\tikzstyle{block} = [draw, rectangle, 
	minimum height=3em, minimum width=6em]
	\tikzstyle{sum} = [draw,  circle, node distance=1cm]
	\tikzstyle{input} = [coordinate]
	\tikzstyle{output} = [coordinate]
	\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]
	\begin{figure*}[t]
		\begin{tikzpicture}[auto, node distance=2cm,>=latex',scale=1]
			\centering
			\node [block,scale=.8, pin={[pinstyle]above:$\Delta=\Delta_0$},
			node distance=5cm] (RMPC) {RMPC design (MATLAB)};
			\node[] (partitions) at (2.5,.5){\includegraphics[width=.08\textwidth]{Figs/regs.jpg}};
			\node [block, scale=1,right of=RMPC,
			node distance=5cm,text width=3cm] (mixed) {Mixed precision computation (Daisy)};
			\node [draw, diamond, 
			minimum height=3em, minimum width=3em, right of=mixed,
			node distance=5cm] (decide) {$N_b\leq \bar N_b$};
			\node [block, right of=decide,
			node distance=3cm] (done) {Done};
			\node [block, below of= decide,
			node distance=3cm] (delta) {increase $\Delta$};
			\node [scale=.3] at (2.25,-.5)  {
				$
				K(x_k)=
				\begin{cases}
				F_1x_k+G_1 & \text{if $x_k\in \mathcal{R}_1$}\\
				F_2x_k+G_2 & \text{if $x_k\in \mathcal{R}_2$}\\
				\vdots\\
				F_Px_k+G_P & \text{if $x_k\in \mathcal{R}_P$}
				\end{cases} 
				$
			};
		\node at (7.5,-.35) {$N_b$};
			
			
			\draw [draw,->] (RMPC) -- node [pos=-.1] {}(mixed);
			\draw [->] (mixed) -- node [name=aaa] {}(decide);
			\draw [->] (decide) -- node [above,pos=.3] {Yes} (done);
			\draw [->] (decide) -- node[pos=0.99] {} 
			node [] {No} (delta);
			\draw [->] (delta) -| node [above] {} (RMPC);
	
	\end{tikzpicture}
	\caption{high level description of the proposed memory-efficient robust MPC design}
	\label{fig:overview}
\end{figure*}