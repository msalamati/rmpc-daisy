% !TEX root = main.tex
\section{Overview}\label{sec:example}

% Model Predictive Control (MPC) refers to the class of control strategies that design control actions by solving a finite horizon optimal control problem at each sampling instant. While each optimization gives a sequence of optimal control actions, only the first action is applied to the process. The same procedure is applied in the next time instance after receiving the updated value of the process state. MPC has shown to be successful in industrial applications since it is able to handle large number of states and control actions and automatically considers constraints in the optimization.
% 
% The optimization of each time instance uses a dynamic model of the process to predict the future states and find the optimal sequence of actions that satisfies all the constraints. The objective function of the optimization is usually linear or quadratic. The resulting optimization problem can be cast as a linear program (LP) or quadratic program (QP), respectively, if the dynamic model is linear. For hybrid models with linear dynamics in each mode, the optimization problem can be cast as a mixed integer linear or quadratic program (MILP/MIQP). 


\begin{figure}[t]
	\begin{tabular}{cc}
	\includegraphics[width=2cm,height=3cm]{Figs/inv_pend.png}&	\includegraphics[width=6cm,height=4cm]{Figs/regs.jpg}\\
	(a)&(b)
	\end{tabular}
	\caption{(a) Inverted pendulum; (b) 2-D plot of polyhedral partitions for an explicit MPC applied to the inverted pendulum.}
	\label{fig:inverted_pendulum}
\end{figure}

As a smaller example, consider the standard problem of designing a controller for an inverted pendulum depicted in~\autoref{fig:inverted_pendulum}~{(a)}.
The goal of the controller is to keep the pendulum at the vertical position while satisfying hard constraints on the state variables and control inputs.
A model of the system can be constructed using physical principles. 
After linearization and time discretization, the model is
	\begin{equation}
		\begin{bmatrix}
			 \theta_{k+1}\\
			\omega_{k+1}
		\end{bmatrix}=
		\begin{bmatrix}
			1 & T_s\\
			\frac{T_sg}{L}& (1-\frac{T_sb}{mL^2})		
		\end{bmatrix}
		\begin{bmatrix}
			\theta_k\\
			\omega_k
		\end{bmatrix}+
		\begin{bmatrix}
			0\\
			\frac{T_s}{mL^2}
		\end{bmatrix}u_k + w_k
		\label{eq:pendul_ss}
	\end{equation}
where $\theta_k$, $\omega_k$, and $u_k$ denote respectively the angular position, angular speed, 
and the input torque at time $kT_s$ with $T_s$ being an appropriate sample time.
The disturbance $w_k\in\mathbb R^2$, bounded by $\|w_k\|\leq \Delta$, captures the modeling error due to 
linearization and discretization. 
The parameter $g=9.81 [m/s^2]$ is the gravitational acceleration, $m$ is the ball mass, $b$ is the rotational fraction coefficient, 
and $L$ is the length of the bar. 
Starting from an initial state $(\theta_0,\omega_0)$, the control goal is to converge to the equilibrium point 
$\theta=0, \omega=0$.
Additionally, we require the state constraints $\theta_k\in[-\pi,\pi]$ and $\omega_k\in[-\pi/8,\pi/8]$ to hold at all time instances.

Our overall goal is to 
(i) design a robust MPC controller that achieves the performance objectives including hard constraints in spite of a bounded
disturbance $\Delta$ modeling the implementation error due to finite precision;
and at the same time
\eva{what about the modelling error that $\Delta$ bounded in the paragraph before?}
(ii) to minimize the total number of bits that are required for storing the explicit controller 
while ensuring the error $e\leq \Delta$ is satisfied by the implementation.

% There are many control schemes that can guarantee convergence of the trajectories to the rest position (e.g., state feedback or linear quadratic regulator), but fail to ensure hard constraints on the states at all time instances. The main feature of MPC schemes is to automatically include these constraints in the design of control actions.
%	One major challenge of implementing model predictive controllers over embedded systems is to solve the related optimization within each sampled time inerval. Since the system under consideration is LTI, one can use explicit MPC \cite{Bemporad:2002} that computes partitions over state space together with affine functions which are then used to compute the optimal control input over their corresponding partition. For the inverted-pendulum example, the computed controller contains $12$ partition presented in Fig.~\ref{fig:inverted_pendulum}~{(b)}, each with an affine function that gives the control action over that partition.
	
%	In many practical applications, explicit MPC is implemented over relatively low-price embedded systems with limited memory capacity and computational power. The partitions together with the affine functions should be stored on the embedded system.
%	Computing the control action, i.e., evaluating the affine function for a specific state, can be performed efficiently using for example binary tree search. However, the memory limitations is more crucial since the memory usage increases linearly with the number of partitions.
%	In this paper we discuss a method for reducing the memory usage in applying explicit MPC to LTI dynamical systems.
	
%	Many low-end embedded systems only support fixed point arithmetic which causes errors that is inversely proportional to the number of bits used for representing each variable. It is necessary to account for such errors in the design stage of the controllers to be able to enforce hard constraints on the states at the final implementation of the controller. Our proposed method iteratively solves a robust version of the MPC with varying bound on the disturbance to include such errors.   %Therefore, one needs to formulate the problem as robust EMPC to count for disturbance input $|\delta|\leq \Delta$ which is summed up with the control input torque $u$ in each time step.
	 %Setting the number of bits for storing different variables, one can compute the upper bound for approximation error, $\bar\omega$.
	%However, we would like to achieve the minimum number of bits to reduce memory requirements.
	
%	In summary, we design a robust explicit MPC, taking fixed-point arithmetic errors into account and find a minimal set of mixed precision assignments for all the quantities that must be stored on the embedded system. 
% Denote the overall error produced by the fixed finite precision implementation by $e$.

%Our approach iteratively expand the bound on disturbance $\Delta+\Delta_0$, designs a robust explicit MPC controller with this bound and 
% uses state-of-the-art fixed-point error analyzers to find the minimum total number of bits for storing the controller into the embedded system with maximum error $\Delta_0$.
	
Figure \ref{fig:overview} gives a high-level overview of our proposed setup. 
We start by defining an initial bound $\Delta_0$. 
For our example, we choose $\Delta_0=0$. 
We use MATLAB to find a robust explicit MPC with the bound $\Delta_0$ on the disturbance.
Next, we ask Daisy
to provide us with a mixed-precision scheme such that the implementation satisfies the error bound $\Delta$, that is,
at all points in the control domain, the difference between the (infinite precision) controller function
and its implementation in the mixed-precision scheme is at most $\Delta$.

Unfortunately, $\Delta_0=0$ is not realizable,  as the error resulting from a fixed-point 
implementation is always greater than zero. 
Therefore, we increase $\Delta$ by $0.05$ and try again. 
Solving the robust explicit MPC problem for the new disturbance bound gives the new controller,
shown in Figure~\ref{fig:inverted_pendulum}(b).
The controller has \RM{XX} regions.
\RM{give the control function. I think it will be good to explicitly write the polyhedra and the affine maps} 

Next, we ask Daisy to provide us with mixed-precision implementation for all the parameters and to compute a static bound on the
implementation error. 
The mixed-precision scheme given by Daisy results in an implementation with $6084$ bits in total 
for the corresponding robust explicit MPC.
Daisy also computes a static error bound of \RM{what?}
Since this error bound is less than our robustness margin $\Delta = 0.05$, we terminate the loop
and return this implementation.
The mixed-precision implementation takes about $10\%$ less memory compared 
to the smallest uniform precision implementation that respects $\Delta$,
and about $XXX\%$ \RM{what} less memory than an implementation that uniformly uses
32 bits.
	
	
	\tikzstyle{block} = [draw, rectangle, 
	minimum height=3em, minimum width=6em]
	\tikzstyle{sum} = [draw,  circle, node distance=1cm]
	\tikzstyle{input} = [coordinate]
	\tikzstyle{output} = [coordinate]
	\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]
	\begin{figure*}[t]
		\begin{tikzpicture}[auto, node distance=2cm,>=latex',scale=1]
			\centering
			\node [block,scale=1,,text width=3.5cm, pin={[pinstyle]above:$\Delta=\Delta_0$},
			node distance=1cm] (RMPC) {Robust explicit MPC design (computed by MATLAB)};
			%\node[] (partitions) at (2.5,.5){\includegraphics[width=.08\textwidth]{Figs/regs.jpg}};
			\node [block, scale=1,right=2.5cm of RMPC,
			node distance=5cm,text width=4cm] (mixed) {Finite precision implementation (computed by Daisy)};
			\node [draw, diamond, 
			minimum height=3em, minimum width=3em, right =1cm of mixed,
			node distance=5cm] (decide) {$e\leq \bar \Delta$};
			\node [block, right of=decide,
			node distance=3cm] (done) {Done};
			\node [block, below of= decide,
			node distance=3cm] (delta) {increase $\Delta$};
			\node [scale=1] at (3,-.25)  {
				$u(x)=Kx+v$
			};
		\node at (9,-.25) {$e$};
			
			
			\draw [draw,->] (RMPC) -- node [pos=-.1] {}(mixed);
			\draw [->] (mixed) -- node [name=aaa] {}(decide);
			\draw [->] (decide) -- node [above,pos=.3] {Yes} (done);
			\draw [->] (decide) -- node[pos=0.99] {} 
			node [] {No} (delta);
			\draw [->] (delta) -| node [above] {} (RMPC);
	
	\end{tikzpicture}
	\caption{high-level description of the proposed memory-efficient robust MPC design
\RM{what is $\bar{\Delta}$}
\RM{try to draw a better picture spanning only one column. the information in this pic is sparse}
\RM{why is $u$ a single affine map?}
\RM{why is Daisy only giving $e$? Shouldn't it also return the best mixed precision impl?}
}
	\label{fig:overview}
\end{figure*}

	
