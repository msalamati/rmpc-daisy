%!TEX root = main.tex
\section{Error Analysis}
\label{sec:Error_Analysis}

We first present our error analysis assuming given fixed-point word lengths,
before explaining our optimization algorithm which determines suitable word
lengths fully automatically in~\autoref{sec:Controller_Synthesis}.
While we do not employ the error analysis independently of controller and
precision synthesis, we note that it is an alternative way of bounding errors to
existing methods~\cite{imperialrmpc}.

For simplicity of notation, we assume a uniform word length $p$ in this section,
though our algorithm (and implementation) support mixed-precision as well.

The output of an explicit MPC controller can be affected by two main sources
errors, which an error analysis has to capture\cite{imperialrmpc}:
\begin{itemize}
  \item[(i)] \emph{incorrect region selection}: 
    due to analog-digital conversion and quantization of $H_i$ and $K_i$,
    the controller can choose an incorrect control action $u_j$ instead of $u_i$
    
  \item[(ii)] \emph{approximate control output}: the control output is computed
    using quantized $F_i$ and $G_i$, accumulating errors.
\end{itemize}

We have to ensure that these errors remain below the error bound $\Delta$
used to design the robust MPC controller:
\begin{align}\label{eq:delta}
  \max_{\forall i,j. \mathit{neighbor}(\mathcal{R}_{i},\mathcal{R}_{j})}|u_{i}-u_{j}| + \max_{\forall i.\mathcal{R}_{i}\in\mathcal{R}} err(u_{i})_{p} \le \Delta
\end{align}
where $i,j$ are the indexes of two distinct regions $\mathcal{R}_{i}$ and
$\mathcal{R}_{j}$, \\ $\mathit{neighbor}(\mathcal{R}_{i},\mathcal{R}_{j})$
states that two regions share at least a point, $u_{i}$ is the control action
for controller $i$, and $err(u_{i})_{p}$ captures the approximation error for
computing the control action $u_{i}$ in fixed precision $p$.

\subsection{Incorrect Region Selection}

The first part of the error in~\autoref{eq:delta} captures the error due to
selecting of the wrong control action. That is, with infinite-precision arithmetic
and in the absence of any uncertainty from hardware measurements we would choose
control action $u_i$, but due to uncertainties we actually choose control action $u_j$:
\begin{align} \label{eq:maximization}
  \max_{\forall i,j.\mathit{neighbor}(\mathcal{R}_{i},\mathcal{R}_{j})}|u_{i}-u_{j}|&= \\
  \max_{\forall i,j.\mathit{neighbor}(\mathcal{R}_{i},\mathcal{R}_{j})}&|F_{i}\statevar+G_{i} - (F_{j}\statevar+G_{j})|\nonumber
\end{align}

%Because of the linearity of the function $u_{i}-u_{j}$, and because of the
%convexity of the regions $i$ and $j$, it is enough to evaluate function
%(\ref{eq:maximization}) at the corner points of the \texttt{tube}, instead of
%solving a maximization problem.

A naive computation of this error would consider all possible values of $x_k$.
This would lead to a gross over-approximation, however, since the controller
will choose a wrong region only in a relative narrow neighborhood, or
\emph{tube}, around the boundary between two regions $R_i$ and $R_j$.

The border between two regions $\mathcal{R}_{i}$ and $\mathcal{R}_{j}$ is defined by 
their corresponding boundaries:
\begin{equation}
\mathit{border}_{i,j} :=(H_i \statevar - K_i ) - (H_j \statevar - K_j)
\end{equation}
for appropriate matching borders $H_i, K_i$ and $H_j, K_j$.

In~\autoref{eq:maximization}, we thus constrain $\statevar$ to be within an appropriate tube:
\begin{equation}\label{eq:tube}
|\mathit{border}_{i,j}| \le \varepsilon
\end{equation}
where $\varepsilon$ captures the uncertainty in computing the
correct region and thus the width of the tube.
%
The width of the tube $\varepsilon$ is due to two sources of errors:
analog-to-digital conversion $\varepsilon_{A/D}$ and the quantization of region
bounds in memory $\varepsilon_{Q}$:
\begin{equation}\label{eq:epsilontot}
  \varepsilon=\varepsilon_{A/D}+\varepsilon_{Q}
\end{equation}

Analog conversion happens just before the controller receives the sensor input from the plant
and is given by:
\begin{equation*}
\varepsilon_{A/D}=\frac{V_{cc}}{2^{r}-1}
\end{equation*}
where $V_{cc}$ is the reference voltage of the converter (e.g. typically 5V), $r$
is the number of bits available to quantize the analog signal, and $2^{r}$ is
the resolution of the converter.

While $\varepsilon_{A/D}$ is intrinsic to the capabilities of the device,
$\varepsilon_{Q}$ depends on the precision used to store the boundaries:
\begin{equation}\label{eq:quantizationlines}
  \varepsilon_{Q} = |(H_i - \hat{H}_i) \qstatevar + (K_i - \hat{K}_i)|
\end{equation}
\eva{For which index is this evaluated, $i$, $j$ or both?}
That is, $\varepsilon_{Q}$ bounds the distance between any hyperplane in infinite
precision (H and K), and its counter-part quantized in $p$ bits precision
($\hat{H}_{p}$ and $\hat{K}_{p}$).
This second error can be tuned providing a trade-off between accuracy and
memory storage required.


\subsection{Approximate Control Output}

Once a control action $u_i$ is chosen, computing $u_{i}$ itself introduces
imprecision, because, $u_i$ needs to be evaluated in finite-precision arithmetic:
\begin{equation}\label{eq:fperror}
  err(u_{i})_{p} = | (F_i - \hat{F}_{i}) \statevar + ( G_i - \hat{G}_{i} ) |
\end{equation}
where $\hat{F}$ and $\hat{G}$ represent the quantized values (in $p$ bits) for
the infinite precision values $F$ and $G$.

\autoref{eq:fperror} is evaluated for all \statevarmath that are inside the
region $\mathcal{R}_i$, together with all the values in the tube surrounding
region $\mathcal{R}_i$.
In this way we compute the error also for those points that belong to a neighbor
of $\mathcal{R}_i$, but because of finite-precision errors they are erroneously
mapped to control action $u_i$.


\subsection{Implementation}

%The incorrect region error (\autoref{eq:maximization}) is computed using Matlab's multi-parametric toolbox. 
Due to the affinity of function
$u_{i}-u_{j}$, and because we defined the tube as a convex region surrounding the corresponding hyperplane, it suffices
to evaluate the function only at the corner points of the tube, and keep the
result with the maximal magnitude. To evaluate the point location error across the corner points, we need to first locate the corner points as well as all the regions which share those corner points. We start by computing the vertices for each region $R_i$ by converting the convex set of constraint inequalities for that region into the set of vertices at the intersections of those inequalities using existing tools such as $\mathit{lcon2vert}$ written for MATLAB (\cite{????}). The computed vertex $v_i$ will be associated with a $n-D$ hypercube with the edge length of $2 \varepsilon$. Each of the $2^n$ vertices of this hypercube is counted as a corner point. In order to find out which regions have the same vertex $v_i$, one approach is to compute and save the set of vertices for all the regions and then to find out the neighboring regions via exhaustive search with the saved set of vertices. Alternatively, for the vertex $v_i$, all the regions $R_j$s having $v_i$ as their vertex can be identified if at least $n$ of their hyperplanes cross $v_i$. We used both approaches; however, the later scales up better when we have millions of vertices. In brief, we go through these steps: (i) for each region, the set of vertices are computed; (ii) for the vertex $v_i$, the set of all regions $\mathcal R_{ij}$ having $v_i$ as their own vertex are found; (iii) for the vertex $v_i$, the set of corner points $v_{ik}$ are computed which form a hypercube centering at $v_i$; (iv) for every corner point $c_k=v_{ik}$ and for every pair $(\mathcal R_{ij1},\mathcal R_{ij_2})$, the corresponding corner error $|u_{j1}-u_{j2}|$ is computed; (v) finally, we pick the greatest corner error.

\eva{This needs more details. Which function(s) and algorithm from Matlab are used?}
\eva{How do you determine which regions are neighbors? resp. which borders are matching?}


$\varepsilon_Q$ and $err(u_{i})_{p}$ are computed by Daisy. For this we encode
the expressions in~\autoref{eq:quantizationlines} and \autoref{eq:fperror}
respectively as straight-line arithmetic expressions and specify the constraints
on the domain of $\statevar$ in the precondition.
Daisy performs a dataflow analysis to determine the finite-precision roundoff
errors. This error computation differs from the one employed by
\citet{imperialrmpc} which phrases the roundoff error computation as a (relaxed)
mixed integer programming problem.

While our actual synthesis algorithm (\autoref{sec:Controller_Synthesis}) does
not compute the errors $\varepsilon_Q$ and $err(u_{i})_{p}$ explicitly, the
error verification is used internally by Daisy to determine a suitable precision
$p$ and can also be called explicitly without the precision optimization.

% The approximation error and the precision tuning for both borders and active
% functions are computed in Daisy. $\varepsilon_{Q}$ is given in input to the
% analysis. After we compute the incorrect region in MATLAB we obtain the value
% for max error $err(u_{i})$ from (8). Then we give the errors and the vectors F,G
% and H,K in input to Daisy. We used Daisy as a verification tool: we provide in
% input the expression we want to quantize (e.g. $\mathcal{R}_{i}$) together with
% the error bound we can tolerate (e.g. $\varepsilon_{Q}$), and Daisy returns a
% precision configuration (uniform or mixed) such that the input error is
% satisfied. The way it finds the right configuration for uniform precision is the
% following: it starts by checking whether the input expression, quantized in
% unary uniform precision (1bit), introduces an error bounded by the input error.
% If this is not the case, Daisy increases the precision format by 1 bit and check
% whether the error now is satisfied. This unary increment runs inside a loop that
% terminates when the first valid format is matched. This uniform word-length is
% going to be the baseline for the mixed-precision tuning phase. The
% mixed-precision algorithm keeps a list of variables to quantize, and collects
% different candidate configurations that satisfy the input error. It returns the
% best configuration based on the evaluation of a quality function.


